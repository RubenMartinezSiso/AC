#!/usr/bin/python3
# -*- coding: cp1252 -*-
"""System module."""
import sys
import cmath
sys.setrecursionlimit(100000)

def ac_impossible(index):
    """ac_impossible: Comprobar si el acueducto es imposible iterativo"""
    impossible = False
    while (index < NUMBER-1 and not impossible):
        radius = (XS[index+1] - XS[index])/2
        if (HEIGHT - YS[index]) < radius or (HEIGHT - YS[index+1]) < radius:
            #Acueduto imposible
            impossible = True
        index += 1
    return impossible

def pu_impossible(index):
    """pu_impossible: Comprobar si el puente es imposible iterativo"""
    impossible = False
    radius = (XS[NUMBER-1] - XS[0])/2
    #1: Buscar x del punto medio (siempre es el mismo)
    medio = (XS[NUMBER-1] - XS[0])/2 + XS[0]
    while (index < NUMBER and not impossible):
        #Necesito una test_x y test_y (punto que he de comprobar)
        test_x = XS[index]
        test_y = YS[index]
        #2: Calcular up_x
        up_x = test_x - medio
        #3: Calcular up_y
        up_y = cmath.sqrt(radius**2 - up_x**2)
        #4: Cacular altura
        alt = up_y + (HEIGHT - radius)
        #5: Comprobar que no pase la altura
        test_y_complex = complex(test_y)
        if alt.real <= test_y_complex.real:
            #Puente imposible
            impossible = True
        index += 1
    return impossible

def sumhit(index):
    """sumhit: calcular el sumatorio de hi iterativo"""
    sumh = 0
    while index < NUMBER:
        sumh = sumh + (HEIGHT - YS[index])
        index += 1
    return sumh

def sumdit(index):
    """sumdit: calcular el sumatorio de di iterativo"""
    sumd = 0
    while index > 0:
        sumd = sumd + (XS[index] - XS[index-1])**2
        index -= 1
    return sumd

if len(sys.argv) == 2:
    #Abrir el fichero y leer la primera linea (split para separar los DATOS)
    FILE = open(sys.argv[1])
    DATOS = FILE.readline()
    DATOS2 = DATOS.split()
	#Guardar datos de la primera linea
    NUMBER = int(DATOS2[0])
    HEIGHT = int(DATOS2[1])
    ALFA = int(DATOS2[2])
    BETA = int(DATOS2[3])
	#Guardar coordenadas de los puntos
    XS = [0 for _ in range(NUMBER)]
    YS = [0 for _ in range(NUMBER)]
    for i in range(NUMBER):
        DATOS = FILE.readline()
        DATOS2 = DATOS.split()
        XS[i] = int(DATOS2[0])
        YS[i] = int(DATOS2[1])
    FILE.close()
else:
    #En caso de no recibir un archivo, pedir valores por terminal
    print("Ningun archivo por parametro")
    NUMBER = input("NUMBER:")
    NUMBER = int(NUMBER)
    HEIGHT = input("HEIGHT:")
    HEIGHT = int(HEIGHT)
    ALFA = input("ALFA:")
    ALFA = int(ALFA)
    BETA = input("BETA:")
    BETA = int(BETA)
    EXIT = False
    XS = []
    YS = []
    while not EXIT:
        X = input("x:")
        X = int(X)
        XS.append(X)
        Y = input("y:")
        Y = int(Y)
        YS.append(Y)
        SALIR = input("Introducir EXIT para calcular (introducir cualquier cosa para continuar introduciendo puntos)\n")
        if SALIR == "EXIT":
            EXIT = True
#COST1: acueducto
COST1 = -1
if not ac_impossible(0):
    SUMH = sumhit(0)
    SUMD = sumdit(NUMBER-1)
    COST1 = ALFA*SUMH + BETA*SUMD
#COST2: puente
COST2 = -1
if not pu_impossible(1):
    SUMH = (HEIGHT - YS[0]) + (HEIGHT - YS[NUMBER-1])
    SUMD = (XS[NUMBER-1] - XS[0])**2
    COST2 = ALFA*SUMH + BETA*SUMD
#Elegir el mejor coste o impossible
if COST1 == -1 and COST2 == -1:
    print ("impossible")
elif COST1 != -1 and COST2 == -1:
    print (COST1)
elif COST1 == -1 and COST2 != -1:
    print (COST2)
elif COST1 <= COST2:
    print(COST1)
else:
    print(COST2)
